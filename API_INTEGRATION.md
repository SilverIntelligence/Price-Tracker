# API Integration Guide

This guide shows how to integrate real price data APIs with the WSS Price Tracker.

## Current State

The app currently uses **mock data** generated by `generateMockData()` in `src/prices.ts`. This is perfect for development and testing, but you'll want real data for production.

## Option 1: TwelveData API

[TwelveData](https://twelvedata.com/) provides comprehensive financial market data.

### Setup

1. **Sign up**: https://twelvedata.com/register
2. **Get API key**: Dashboard â†’ API Keys
3. **Free tier**: 800 API calls/day

### Implementation

Edit `src/prices.ts`:

```typescript
function buildApiUrl(
  symbol: Asset,
  interval: Interval,
  limit: number = 120
): string {
  // Map our intervals to TwelveData format
  const intervalMap: Record<Interval, string> = {
    '1m': '1min',
    '5m': '5min',
    '15m': '15min',
    '30m': '30min',
    '1h': '1h',
    '4h': '4h',
    'D': '1day',
    'W': '1week',
  };

  return `https://api.twelvedata.com/time_series?` +
    `symbol=${symbol}&` +
    `interval=${intervalMap[interval]}&` +
    `outputsize=${limit}&` +
    `apikey=YOUR_API_KEY`;
}

function parseApiResponse(data: any, symbol: Asset, interval: Interval): PriceFeed {
  // TwelveData response format:
  // { values: [{datetime, open, high, low, close}], meta: {...} }

  const candles: Candle[] = data.values.map((v: any) => ({
    t: new Date(v.datetime).getTime(),
    o: parseFloat(v.open),
    h: parseFloat(v.high),
    l: parseFloat(v.low),
    c: parseFloat(v.close),
  })).reverse(); // Oldest to newest

  const last = candles[candles.length - 1].c;
  const prevClose = candles[candles.length - 2]?.c || last;

  return { symbol, interval, last, prevClose, candles };
}
```

### Set API Key

```bash
devvit secrets set PRICE_API_KEY your_twelvedata_key
```

Then update `getFeed()`:

```typescript
const apiKey = await context.settings.get('PRICE_API_KEY');
const url = buildApiUrl(symbol, interval, 120) + `&apikey=${apiKey}`;
```

## Option 2: Metals.dev API

[Metals.dev](https://metals.dev/) specializes in precious metals pricing.

### Setup

1. **Sign up**: https://metals.dev/
2. **Get API key**: Dashboard
3. **Free tier**: 100 requests/month

### Implementation

```typescript
function buildApiUrl(symbol: Asset, interval: Interval, limit: number = 120): string {
  // Metals.dev uses different symbols
  const metalSymbol = symbol === 'XAGUSD' ? 'XAG' : 'XAU';

  return `https://api.metals.dev/v1/timeseries?` +
    `metal=${metalSymbol}&` +
    `currency=USD&` +
    `start_date=${getStartDate(interval, limit)}&` +
    `end_date=${getTodayDate()}`;
}

function parseApiResponse(data: any, symbol: Asset, interval: Interval): PriceFeed {
  // Metals.dev response: { rates: { "2024-01-01": 31.45, ... } }

  const dates = Object.keys(data.rates).sort();
  const candles: Candle[] = dates.map(date => {
    const price = data.rates[date];
    return {
      t: new Date(date).getTime(),
      o: price,
      h: price,
      l: price,
      c: price,
    };
  });

  const last = candles[candles.length - 1].c;
  const prevClose = candles[candles.length - 2]?.c || last;

  return { symbol, interval, last, prevClose, candles };
}
```

## Option 3: Finnhub API

[Finnhub](https://finnhub.io/) provides stock and forex data.

### Setup

1. **Sign up**: https://finnhub.io/register
2. **Free tier**: 60 API calls/minute

### Implementation

```typescript
function buildApiUrl(symbol: Asset, interval: Interval, limit: number = 120): string {
  const resolution = getResolution(interval); // 1, 5, 15, 30, 60, D, W
  const from = Math.floor((Date.now() - limit * getIntervalMs(interval)) / 1000);
  const to = Math.floor(Date.now() / 1000);

  return `https://finnhub.io/api/v1/forex/candle?` +
    `symbol=${symbol}&` +
    `resolution=${resolution}&` +
    `from=${from}&` +
    `to=${to}`;
}

function parseApiResponse(data: any, symbol: Asset, interval: Interval): PriceFeed {
  // Finnhub response: { c: [], h: [], l: [], o: [], t: [], v: [] }

  const candles: Candle[] = data.t.map((timestamp: number, i: number) => ({
    t: timestamp * 1000,
    o: data.o[i],
    h: data.h[i],
    l: data.l[i],
    c: data.c[i],
  }));

  const last = candles[candles.length - 1].c;
  const prevClose = candles[candles.length - 2]?.c || last;

  return { symbol, interval, last, prevClose, candles };
}
```

## Option 4: Custom Proxy Server

For more control and to avoid rate limits, create your own proxy.

### Node.js Proxy Example

```javascript
// server.js
const express = require('express');
const axios = require('axios');
const app = express();

app.get('/prices', async (req, res) => {
  const { symbol, interval, limit } = req.query;

  try {
    // Fetch from your preferred API
    const response = await axios.get(`https://api.example.com/prices?...`);

    // Transform to our format
    const feed = {
      symbol,
      interval,
      last: response.data.price,
      prevClose: response.data.prev_close,
      candles: response.data.candles.map(c => ({
        t: c.timestamp,
        o: c.open,
        h: c.high,
        l: c.low,
        c: c.close,
      })),
    };

    res.json(feed);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000);
```

Then in `src/prices.ts`:

```typescript
function buildApiUrl(symbol: Asset, interval: Interval, limit: number = 120): string {
  return `https://your-proxy.com/prices?symbol=${symbol}&interval=${interval}&limit=${limit}`;
}
```

## Enabling Production API

Once you've chosen and implemented an API:

1. **Comment out mock data** in `src/prices.ts`:

```typescript
export async function getFeed(
  symbol: Asset,
  interval: Interval,
  context: Devvit.Context
): Promise<PriceFeed> {
  // ... cache checking code ...

  console.log(`Fetching from: ${url}`);

  // REMOVE THIS LINE:
  // const feed = generateMockData(symbol, interval);

  // UNCOMMENT THIS:
  const response = await fetch(url, {
    headers: {
      'Authorization': `Bearer ${await context.settings.get('PRICE_API_KEY')}`,
    },
  });

  if (!response.ok) {
    throw new Error(`API request failed: ${response.status}`);
  }

  const data = await response.json();
  const feed = parseApiResponse(data, symbol, interval);

  // ... caching code ...

  return feed;
}
```

2. **Set your API key**:

```bash
devvit secrets set PRICE_API_KEY your_key_here
```

3. **Rebuild and deploy**:

```bash
npm run build
devvit upload
```

## Rate Limiting Best Practices

### Cache Aggressively

The app already caches data in Redis. Adjust cache duration in `FRESH_MS`:

```typescript
const FRESH_MS: Record<Interval, number> = {
  '1m': 60_000,      // Cache for 1 minute
  '5m': 2 * 60_000,  // Cache for 2 minutes
  '15m': 5 * 60_000, // Cache for 5 minutes
  // ... etc
};
```

### Reduce Cache Warming

If on a free tier, reduce the number of symbols/intervals in `scheduler.ts`:

```typescript
async function warmCache(context: Devvit.Context): Promise<void> {
  const symbols: Asset[] = ['XAGUSD']; // Only silver
  const intervals: Interval[] = ['15m', '1h', 'D']; // Only 3 intervals
  // ...
}
```

### Implement Backoff

Add exponential backoff for failed requests:

```typescript
async function fetchWithRetry(url: string, retries = 3): Promise<Response> {
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(url);
      if (response.ok) return response;
      if (response.status === 429) {
        // Rate limited - wait longer
        await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
        continue;
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (i === retries - 1) throw error;
      await new Promise(r => setTimeout(r, 1000 * (i + 1)));
    }
  }
  throw new Error('Max retries exceeded');
}
```

## Testing Your Integration

### 1. Test Locally

```bash
devvit playtest
```

Watch the console for API calls and responses.

### 2. Test Different Intervals

Switch between 1m, 15m, 1h, etc. to ensure all timeframes work.

### 3. Test Error Handling

- Invalid API key
- Network timeout
- Malformed response
- Rate limit exceeded

### 4. Monitor API Usage

Most providers have dashboards showing:
- Requests per day
- Remaining quota
- Error rates

## Troubleshooting

### "Failed to parse API response"

- Check the API response format matches your `parseApiResponse()` function
- Log the raw response: `console.log(JSON.stringify(data))`
- Verify date/number parsing

### "Rate limit exceeded"

- Increase cache duration
- Reduce cache warming frequency
- Upgrade to paid API tier
- Switch to custom proxy

### "Symbol not found"

- Verify symbol format (some APIs use `XAG/USD` instead of `XAGUSD`)
- Check if precious metals are supported
- Try forex endpoints instead

### Charts showing flat lines

- Ensure OHLC values are different (not all using close price)
- Check time series is ordered correctly
- Verify timestamps are in milliseconds

## Cost Estimation

### Free Tiers

| Provider | Free Limit | Est. Cost if Exceeded |
|----------|------------|---------------------|
| TwelveData | 800/day | $8/mo for 8000 |
| Metals.dev | 100/month | $10/mo for 1000 |
| Finnhub | 60/min | $0 (generous free) |

### With Caching

Assuming 1000 daily active users:
- Cached requests: ~95% hit rate
- API calls needed: ~50-100/day
- Cost: **Free tier sufficient**

## Recommended Setup

For r/WallStreetSilver:

1. **Start with**: TwelveData (free tier)
2. **Cache duration**: 2-5 minutes for most intervals
3. **Warm cache**: Only for 15m and 1h intervals
4. **Monitor**: Set up alerts for quota usage
5. **Upgrade when**: Hitting 80% of free quota

---

**Need help?** Check the [Deployment Guide](DEPLOYMENT.md) or ask in r/WallStreetSilver!
